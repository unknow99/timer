1.上电后，程序必须从bootloader区域启动
2.bootloader需要支持外部USART，USB，SD卡，EMMC，备份数据存入DDR读取文件升级
3.获取到的文件根据flash的块大小进行拆分；写入FLASH，然后再读出校验
4.文件可选择写入内部flash或者外部QSPIflash

注意事项
1.跳转需要设置主堆栈MSP指针和VTOR栈顶指针，MSP是栈顶指针的读出值，跳转地址是栈顶+4的读出值
2.bootloader写入到0x08000000
3.升级需要的数据总线需要：每次读取一个或者多个块大小的数据量，然后校验写入
4.bootloader写入flash之前，
	关总中断
	初始化QSPI，先不映射，后续需要跳转的时候再映射
	初始化升级通信的外设，挂载文件系统，轮询升级媒介，优先级：SD>USB>USART>EMMC，如有升级事件
		备份APP区域的原flash到DDR（需要校验，校验失败回复错误码或者记录错误log，然后直接跳过升级过程）
		存储媒介升级条件：当前固件和已有固件信息不一致，或者bin存在，但log不存在（已有固件会在升级之后写入log）
		通信媒介升级条件：一定时间内有升级开始升级的数据包
	写入flash中：
		解锁flash
		循环：{以flash块区域为单位，读取升级包
		如果剩余长度不足一个块，剩余部分填充0xff
		按顺序：擦除flash，写入flash，取出flash，校验flash
		上面的校验指的是获取到的块数据包，与写入之后flash再取出的数据包校验作对比
		如校验失败，读取失败，写入失败等异常情况下，记录错误状态，break当前升级流程，
		}
	写入flash之后：
		如果是存储媒介升级：
			升级失败，恢复之前固件（恢复时读取失败，写入失败，校验失败），记录log
			更新升级log，包括固件大小，固件文件名，固件总校验值
			关闭文件
			开中断
			跳转APP
		如果是通信媒介升级：
			升级失败，恢复之前固件（恢复时读取失败，写入失败，校验失败），给出回复消息
			升级成功，给出回复消息
			开中断
			跳转APP
		其他说明：跳到QSPI时，不要复位QSPI


*************************特别说明：
					1.调试阶段不要真的写入flash，写入DDR内存就行，也不要跳转
					2.写入flash需要自定义一个写入函数
					3.读取数据包也需要一个自定义函数来抽象不同的媒介
					4.做校验，最简单的校验和或者异或校验就行
					5.跳转APP函数需要复位所有外设
					6.写入固件到QSPI，从写入时开始需要额外启用映射
					7.跳转到QSPI，如写入失败（读包，写包，校验），关闭映射
					7.数据结构至少有
						固件写入的目标地址（内部或者外部）
						固件来源通道（emnu）
						固件的大小
						固件已写入目标地址的总大小
						固件的读，写，校验完成标志位
						flash的区块大小
						
						备份区域的地址
						备份区域的大小
						
						

获取输入通道
	存储介质：读取文件，有固件名，大小变化则更新
	通信介质：
		目标方：清除接受buff，重新开启接受，空闲中断发生->检查字段->检查成功->回复应答
		发起方：定时发送message，如没有收到ACK，一直发送，收到ACK,发送升级包大小
获取升级包总大小
	存储介质：读取文件，获取objsize
	通信介质：
		目标方：清楚接受buff，重新传输，空闲中断->搜索字段->搜索成功，回复ACK
		发起方：定时发message,如果没有ACK，一直发送，收到ACK进入下一阶段

传输升级包				
	存储介质：按扇区大小，读取数据，写入到地址
		三个文件：一个数据文件，一个地址文件，一个log文件
		log写入完成之后更新
	通信介质：
		√st1.发起方发送数据包总大小和写入的addr，等待ACK
		√st2.目标方收到数据包，解析，得到每次数据包的大小
	    和addr剩余空间
		    如果空间足够，回复肯定响应
	    	    如果不够，回复否定响应，升级结束，执行原程序
		
		√st3.如发起方收到肯定响应，给目标方发送开始CMD
		 √   如发起方收到否定响应，结束升级，通知外部PC端
		st4.目标方收到开始CMD，循环执行：
		 √   目标发起大小信息，超时重发，等待发起方发送（RXNE中断）
		 √   发起方收到大小信息输出固件数据，超时重发，等待ACK
		 √   s1目标方空闲中断产生，检查是否为数据包，如是，回复ACK
		 √   发起方收到ACK，发送校验码，等待ACK
		 √   目标方收到校验码，执行校验，校验成功回复ACK，否则NACK
		 √   发起方收到ACK，回到st4，循环执行，直到剩余数据为0
		 √   发起方收到NACK，回到s1发数据包的地方
	其他说明：st4中不一定需要严格按照顺序执行，写一个命令解释器即可
		双方的报文格式："CMD" <name><size>    <argument><counter>
				    |名字||argu大小||实际数据||计数器|
		支持的CMD(name)需要包含：
3Bytes	1Byte                                4Bytes       ......		4Bytes
head	name   作用                           size        argument		counter
CMD	0x7f   双方都有，PING包			0	  无			.......
CMD	0x01   发起方才有，通知有更新事件	0	  无			.......
CMD	0x02   发起方才有，通知升级包大小   发起方计算	  升级包大小（byte）	.......
CMD	0x03   发起方才有，通知升级地址	    发起方计算    升级目标地址		.......
CMD	0x04   发起方才有，通知开始传输bin      0         无			.......
CMD	0x05   目标方才有，给出传输包大小   目标方计算    传输数据包大小	.......
CMD	0x06   发起方才有，传输数据包	    发起方计算    数据包bin数据		.......
CMD	0x07   发起方才有，传输校验码	    发起方计算    数据包bin校验码	.......

	ACK格式："ACK" <name> <counter>,
	其中，肯定ACK，name不动，否定ACK，name是CMD中name|0x80
3Bytes	1Byte			4Bytes
head	name			counter
ACK	name(name|0x80)		.......


注：
	1.重发机制需要插入延时
	2.printf需要重定义为printf BOOT_LOG
	3.单个block的大小设置，在函数boot_get_update_package中
	4.确定单个block的大小是128KB还是多少，如果是128KB，试一下读写是否成功
	
	
	





		