



内层结构(任务记录表)：
节点状态		bit0:0，没有挂起；bit0:1，挂起；bit31:0阻塞状态，1运行状态
入口函数地址		需要加一个void指针参数
循环次数，		[0-0xffffffff]0则死循环，其他则循环次数
已循环次数
循环周期，		[1-0xffffffff]不能为0，		为0则定时器创建失败
同类周期优先级，	[0 - 0xff]，	为0优先级最高，优先级相同的任务按照创建时间排序
创建时tick值
周期基准		0以创建时tick为基准,非0以总tick为基准
初次执行延迟		非0不延迟（创建后马上执行一次），只能在以创建时tick为基准使用
共享数据队列，  	void指针类型，传入指针
数据队列有效大小，	
最大执行延迟
上一个节点地址
下一个节点的地址	

外层结构（控制句柄）：
当前执行节点指针
当前tick值
当前tick暂停和恢复	0暂停，其他恢复
任务记录表总地址
任务记录表总个数
任务记录表剩余个数
已分配任务节点的个数


API:
√查找空节点，链表的下一个节点地址为空，即为空节点hal_os_Event_Free_Event_Get
√查找优先级位置hal_os_Event_Get_Addr
√创建节点hal_os_Event_Init
√插入节点hal_os_Event_Push
√删除节点hal_os_Event_Pull

挂起节点
恢复节点
设置节点优先级

更新总节拍
节拍总暂停
初始化
任务调度器

√查找优先级位置 返回节点是前待插入节点的前节点的地址
	如果列表满了（任务记录表剩余个数为0），返回NULL
	遍历已分配的列表，遍历次数由外层数据的已分配任务节点的个数决定
	以下规则2选1：
		1.同类优先级节点，先分配的节点优先级更高
			目标优先级>=前节点，且<后节点
			或者目标优先级>=前节点，且遍历到底了
			上述情况返回前节点地址
		2.同类优先级节点，后分配的节点优先级更高
			不采用该规则

√创建节点
	创建节点只负责把已找到的空节点进行赋值，赋值内容如下：
		节点状态		0
		入口函数地址		形参传递
		循环次数，		形参传递
		已循环次数		0
		循环周期，		形参传递
		同类周期优先级，	形参传递
		创建时tick值		先不修改，插入节点再修改
		周期基准		形参传递
		初次执行延迟		形参传递
		共享数据队列，  	形参传递
		数据队列有效大小，	形参传递
		下一个节点的地址	先不修改，插入节点再修改

√查找空节点
	查找空节点本身需要互斥保护，共用互斥
	查找方法：遍历整个任务记录表总地址，一旦发现下一个节点的地址为NULL，则表示已找到，返回该节点地址
√插入节点 
	插入节点本身需要互斥保护，共用互斥
	根据节点优先级，调用API查找优先级位置
	查找到之后（节点不为NULL）
		修改创建时tick值
		下一个节点的地址
		然后直接插到对应节点之后
		更新任务记录表剩余个数--
		更新已分配任务节点的个数++
	
√删除节点 
	删除节点本身API需要互斥保护，共用互斥
	等待节点状态的bit31为0之后，将节点中的所有数据清0，并将节点的上一个地址和下一个地址相连
	更新数据：
		任务记录表剩余个数++
		已分配任务节点的个数--

√挂起节点 只设置节点状态的挂起标志位即可，节点地址通过创建函数返回获得
√恢复节点 只设置节点状态的挂起标志位，
√设置节点优先级 修改节点优先级参数，调用插入节点接口，重新放到对应节点后面

初始化只负责初始化数据，包括内存和外层数据
更新总节拍和任务调度器放在一个线程里面，更新节拍在前
更新总节拍里面需要根据时钟更新总结拍，当节拍暂停时不能更新节拍，不做遍历，遍历留着在调度器里面做
节拍暂停，只设置暂停标志位

任务调度器 需要遍历整个列表，依照当前节拍，分别判断当前任务是否应该执行
	p3当任务挂起，则不执行当前节点的任何操作
	p1当任务入口地址为NULL，不执行任何操作
	p2当循环次数不为0，且当已循环次数等于循环次数，不执行任何操作
    节拍判断
	以创建时间为基准：（当前节拍 - 创建时的节拍）/循环周期 > 已循环次数，则需要执行，同时已循环次数++（为保证执行次数，只能自增）
	以总时钟为基准：判断同上，但是创建时的节拍需要在创建节点时候修改，创建时的节拍 = 当前总节拍/循环周期*循环周期
	上述两种基准节拍判断为OK后，且如果任务没有挂起，需要执行入口函数，入口函数的参数是共享数据队列
	执行入口函数之前需要吧节点状态的bit31写1，执行完之后需要吧bit31写0

	每执行一次节点中的函数，更新数据：
		当前执行节点指针
		已循环次数，上面已经更新，此处不要在更新
		最大执行延迟， 当前延迟 = 当前tick-创建tick-已循环次数*周期
				如果当前延迟>以往最大延迟，即当前延迟 = 最大延迟

    判断完成之后，需要指向下一个地址，每次遍历完一个完整地列表都需要延时1ms，即当前节点的任务地址为NULL，则延时
	
------------------------------------------------------------------------
初始化先清空整个内外层数据，然后
  申请需要的互斥量
  外层数据：
	1.暂停总节拍
	2.当前执行节点指针为NULL
	3.当前tick值为0
	4.最大执行延迟为0
	5.任务记录表总地址为某个数组地址
	6.任务记录表总个数为数组个数
	7.任务记录表剩余个数为数组个数-1
	8.已分配任务节点的个数为0

将任务记录表总地址全写为0，下一个节点的地址写为NULL（此处讲究顺序）

  内层数据（全都存放在 任务记录表总地址中）：
	0.节点状态		0x80000000
	1.入口函数地址  	0
	2.循环次数      	0
	3.已循环次数		0
	4.循环周期		0
	5.同类周期优先级	0
	6.创建时tick值		0
	7.周期基准		0
	8.初次执行延迟		0
	9.共享数据队列		0
	10.数据队列有效大小	0
	11.下一个节点的地址	节点本身的地址
  
恢复暂停状态

------------------------------------------------------------------------
	








API:
配置新节点2 
删除节点2
挂起节点 不冲突
恢复节点 不冲突
设置节点优先级2


查找空节点1 和本身冲突
查找优先级对应位置2 和配置新节点，删除节点设置节点优先级冲突














